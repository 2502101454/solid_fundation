# 导入是运行时的运算，程序第一次导入指定文件时，会执行三个步骤
# 1.找到模块文件   2.编译成字节码文件（需要时）     3.执行模块代码来创建其所定义的对象(执行的是字节码)
# 这三个步骤是在程序执行时，模块第一次导入时才会进行，后续导入相同的模块则会跳过这三个步骤，直接提取内存中已加载的模块对象
# 从技术上讲，Python把载入的模块存储在一个名为sys.modules的表中，并在开始导入前检查该表，如果模块不存在则启动上述三个过程

# import 和 from都会执行模块文件里全部的代码。两者都是导入操作，所以都遵循上述机制，如果先import 后续再from，那么也是直接取内存中的模块对象
# from的第一步也是普通的导入操作，因此，它会将整个模块导入到内存中(如果还没被导入的话)

# import 语句使一个变量名引用整个模块对象，我们通过模块名称来得到该模块的属性     变量整体指向模块
# from只是把变量名复制到另一个作用域，以from复制的变量名会变成共享对象的引用      from xxx import a 只是存在变量a指向了内存中模块对象xx的a变量。
# 接下来直接赋值a=1，并不会改变内存中的值，只是改变本地作用域中的a的值，但是a.append(2)就会改变原处的值了。

# 注意import b.test这种想要引用b内变量写法是错误的（只能用from），import 会把b当做包，然后test当做旗下的模块去搜索

# 模块的搜索路径（按照搜索顺序可以分为如下四类）
# 1.程序的主目录即顶层脚本文件的*目录*   （你就是在solid_fundation这个根目录下执行 python ./module_practice/basic/a.py 和你直接进
#                                     入当前a脚本的目录执行python a.py 这两种方式得出的程序主目录都是一样的，都是绝对路径
#                             /Users/zeng.wang/PycharmProjects/solid_fundation/fundation_practice/module_practice/basic
# 2.PYTHONPATH目录   即PYTHONPATH环境变量中罗列出的所有目录
# 3.标准库目录          python自动搜索标准库安装在机器上的目录，通常这也是不需要添加到PYTHONPATH之中的
# 4.  .pth文件中列出的目录
# 其中1 3是在程序运行时自动定义的；2 4是可以自行扩展的

# 本质上，在程序启动时，sys.path是模块的搜索路径，它自动按顺序将1 2 3 4 对应的路径进行合并，组成一个list，后续Python在每次导入
# 一个新文件的时候都会从左到右的搜索这个列表中的目录


import b   # 搜索到b(程序主目录下),编译然后执行b内部代码，b内部又import cc.c，继续寻找主目录下cc里的c，执行c里面的代码，又发现import b
            # 但是此时发现b已经在sys.modules中了，所以直接跳过那三个步骤，直接提取内存中的对象b，然后打印b.test，最后执行返回到顶层
            # 脚本文件，接着执行下面的导入以及打印。整个过程给我的感觉就   像方法的调用，最后返回调用处接着往下执行，同时遵守导入机制
import sys
import os

# a作为顶层文件
print(sys.path)
print(os.getcwd())
print(b.test)

# 关于import语法模块导入后变量名的修改以及reload
#  1.导入模块后变量名的修改是发生在内存中，很明显你不可能Import a 后，然后a.test=222,这种操作使得脚本a的代码内容变成test=222，这是不可能的
#  2.reload的操作是对已导入的模块再进行一次从脚本代码内容到内存的转换。
# 所以我们就可以把目光放在如何修改内存中的内容了：
#   1.module.attr = xxx。
#   2.修改module脚本的代码attr=xxx, 然后reload(module)再次执行模块代码
